# 做计划 APP 领域模型设计文档

## 文档信息

| 项目 | 内容 |
|------|------|
| **文档名称** | 领域模型设计文档（DDD） |
| **文档版本** | v2.0 |
| **编写日期** | 2026-01-27 |
| **依据文档** | PRD v2.0、技术约束&规范.md、数据库表设计.sql |
| **设计方法** | 领域驱动设计（DDD） |
| **设计原则** | 高内聚低耦合、可维护性优先、清晰的模块边界 |

---

## 目录

1. [领域划分](#1-领域划分)
2. [DDD 分层架构](#2-ddd-分层架构)
3. [用户上下文（User Context）](#3-用户上下文user-context)
4. [任务上下文（Task Context）](#4-任务上下文task-context)
5. [打卡上下文（CheckIn Context）](#5-打卡上下文checkin-context)
6. [专注上下文（Focus Context）](#6-专注上下文focus-context)
7. [会员上下文（Membership Context）](#7-会员上下文membership-context)
8. [共享内核（Shared Kernel）](#8-共享内核shared-kernel)

---

## 1. 领域划分

### 1.1 限界上下文（Bounded Context）

根据业务需求和职责边界，系统划分为 **5 个核心限界上下文**：

| 上下文 | 职责 | 核心概念 |
|--------|------|----------|
| **用户上下文（User Context）** | 用户账号管理、认证授权、多设备会话 | 用户、设备会话、昵称修改策略 |
| **任务上下文（Task Context）** | 任务管理、重复任务、子任务、四象限 | 任务聚合、子任务、重复策略 |
| **打卡上下文（CheckIn Context）** | 每日打卡、连续天数统计、注销判定 | 打卡记录、坚持统计 |
| **专注上下文（Focus Context）** | 专注会话、倒计时、时长计入规则 | 专注会话、计入策略 |
| **会员上下文（Membership Context）** | 权益管理、订单支付、免费期 | 权益、订单、支付回调 |

### 1.2 上下文映射关系

```
┌─────────────────────────────────────────────────────────────┐
│                      用户上下文 (User)                       │
│         提供：用户身份验证、账号状态查询、设备管理             │
└─────────────────────────────────────────────────────────────┘
       ▲                  ▲                   ▲                ▲
       │                  │                   │                │
       │ ACL              │ ACL               │ ACL            │ ACL
       │                  │                   │                │
┌──────┴──────┐  ┌────────┴─────┐  ┌──────────┴──────┐  ┌────┴──────┐
│  任务上下文  │  │ 打卡上下文   │  │  专注上下文      │  │会员上下文 │
│   (Task)    │  │  (CheckIn)   │  │   (Focus)        │  │(Membership)│
└─────────────┘  └──────────────┘  └──────────────────┘  └───────────┘
```

**说明**：
- **ACL（Anti-Corruption Layer）**：防腐层，各上下文通过防腐层访问用户上下文，避免领域模型污染
- **依赖方向**：所有业务上下文依赖用户上下文（获取用户信息、验证身份）
- **独立性**：任务、打卡、专注、会员上下文之间互不依赖，保持高内聚低耦合

---

## 2. DDD 分层架构

### 2.1 四层架构

```
┌─────────────────────────────────────────────────────────────┐
│                    Interfaces Layer (接口层)                 │
│  - REST Controller (API 接口)                                │
│  - DTO (数据传输对象)                                         │
│  - Request/Response Assembler (组装器)                       │
└─────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                 Application Layer (应用层)                   │
│  - Application Service (应用服务，编排业务流程)               │
│  - Command/Query (命令/查询对象)                             │
│  - DTO Converter (DTO 转换器)                                │
└─────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   Domain Layer (领域层)                       │
│  - Entity (实体)                                              │
│  - Value Object (值对象)                                      │
│  - Aggregate Root (聚合根)                                    │
│  - Domain Service (领域服务)                                  │
│  - Repository Interface (仓储接口)                            │
└─────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────┐
│               Infrastructure Layer (基础设施层)               │
│  - Repository Impl (仓储实现，MyBatis/JPA)                   │
│  - PO (持久化对象，对应数据库表)                              │
│  - 外部服务适配器 (微信支付、推送等)                          │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 各层职责

| 层 | 职责 | 依赖规则 |
|---|------|----------|
| **Interfaces** | 接收 HTTP 请求，参数校验，调用 Application Service | 依赖 Application Layer |
| **Application** | 编排业务流程，调用 Domain Service | 依赖 Domain Layer |
| **Domain** | 业务逻辑、领域规则、不可变性 | 不依赖其他层（纯 POJO） |
| **Infrastructure** | 数据持久化、外部服务集成 | 依赖 Domain Layer（实现接口） |

**依赖倒置原则**：
- Domain Layer 定义 Repository 接口（纯接口）
- Infrastructure Layer 实现 Repository 接口（具体实现）
- 上层依赖下层的抽象，不依赖具体实现

---

## 3. 用户上下文（User Context）

### 3.1 聚合根：User（用户）

**职责**：管理用户账号、打卡统计、昵称修改策略、账号注销

**核心属性**：
```java
class User {
    // 标识
    UserId userId;              // 用户ID（值对象）
    WechatOpenId openId;        // 微信OpenID（值对象）
    
    // 基本信息
    Nickname nickname;          // 昵称（值对象）
    Avatar avatar;              // 头像（值对象）
    IpLocation ipLocation;      // IP属地（值对象）
    
    // 账号状态
    AccountStatus status;       // 账号状态（枚举）
    Instant deactivatedAt;      // 注销时间
    
    // 打卡统计（快照数据）
    ConsecutiveDays consecutiveDays;        // 连续打卡天数（值对象）
    LocalDate lastCheckInDate;              // 最近打卡日期
    int consecutiveUncheckDays;             // 连续未打卡天数
    
    // 昵称修改限制
    NicknameModifyWindow nicknameModifyWindow;  // 昵称修改窗口（值对象）
    
    // 审计字段
    Instant createdAt;
    Instant updatedAt;
}
```

**核心方法**：
```java
// 修改昵称（封装7天内最多2次的业务规则）
void updateNickname(Nickname newNickname);

// 更新打卡统计
void updateCheckInStats(ConsecutiveDays consecutiveDays, LocalDate checkInDate);

// 增加连续未打卡天数
void incrementUncheckDays();

// 重置连续未打卡天数
void resetUncheckDays();

// 注销账号（7天未打卡触发）
void deactivate();

// 判断是否可登录
boolean canLogin();
```

**业务规则**：
1. 昵称修改：7天内最多修改2次
2. 账号注销：连续7天未打卡自动注销，注销后禁止登录
3. 打卡统计：打卡后连续天数+1，未打卡天数清零；未打卡则连续天数清零，未打卡天数+1

---

### 3.2 值对象详细设计

#### 3.2.1 UserId（用户ID）

**职责**：用户唯一标识

```java
public class UserId {
    private final String value;
    
    private UserId(String value) {
        this.value = value;
    }
    
    // 创建新的用户ID（UUID）
    public static UserId newId() {
        return new UserId(UUID.randomUUID().toString());
    }
    
    // 从字符串创建（用于反序列化）
    public static UserId of(String value) {
        if (value == null || value.trim().isEmpty()) {
            throw new IllegalArgumentException("用户ID不能为空");
        }
        return new UserId(value);
    }
    
    public String getValue() {
        return value;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserId userId = (UserId) o;
        return Objects.equals(value, userId.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
    
    @Override
    public String toString() {
        return value;
    }
}
```

---

#### 3.2.2 Nickname（昵称）

**职责**：封装昵称业务规则（长度、违规词校验）

```java
public class Nickname {
    private final String value;
    
    private static final int MIN_LENGTH = 1;
    private static final int MAX_LENGTH = 20;
    private static final Set<String> FORBIDDEN_WORDS = Set.of("管理员", "客服", "系统");
    
    private Nickname(String value) {
        this.value = value;
    }
    
    public static Nickname of(String value) {
        validate(value);
        return new Nickname(value.trim());
    }
    
    private static void validate(String value) {
        if (value == null || value.trim().isEmpty()) {
            throw new IllegalArgumentException("昵称不能为空");
        }
        
        String trimmed = value.trim();
        if (trimmed.length() < MIN_LENGTH || trimmed.length() > MAX_LENGTH) {
            throw new IllegalArgumentException(
                String.format("昵称长度必须在 %d-%d 字符之间", MIN_LENGTH, MAX_LENGTH)
            );
        }
        
        if (containsForbiddenWords(trimmed)) {
            throw new IllegalArgumentException("昵称包含违规词");
        }
    }
    
    private static boolean containsForbiddenWords(String value) {
        return FORBIDDEN_WORDS.stream().anyMatch(value::contains);
    }
    
    public String getValue() {
        return value;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Nickname nickname = (Nickname) o;
        return Objects.equals(value, nickname.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
    
    @Override
    public String toString() {
        return value;
    }
}
```

---

#### 3.2.3 ConsecutiveDays（连续打卡天数）

**职责**：封装连续天数的递增、清零逻辑

```java
public class ConsecutiveDays {
    private final int value;
    
    private static final int MIN_VALUE = 0;
    
    private ConsecutiveDays(int value) {
        this.value = value;
    }
    
    public static ConsecutiveDays zero() {
        return new ConsecutiveDays(0);
    }
    
    public static ConsecutiveDays of(int value) {
        if (value < MIN_VALUE) {
            throw new IllegalArgumentException("连续天数不能为负数");
        }
        return new ConsecutiveDays(value);
    }
    
    // 递增（打卡成功）
    public ConsecutiveDays increment() {
        return new ConsecutiveDays(value + 1);
    }
    
    // 清零（未打卡）
    public ConsecutiveDays reset() {
        return zero();
    }
    
    public int getValue() {
        return value;
    }
    
    public boolean isZero() {
        return value == 0;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ConsecutiveDays that = (ConsecutiveDays) o;
        return value == that.value;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
    
    @Override
    public String toString() {
        return String.valueOf(value);
    }
}
```

---

#### 3.2.4 NicknameModifyWindow（昵称修改窗口）

**职责**：封装"7天内最多修改2次"的业务规则

```java
public class NicknameModifyWindow {
    private final int modifyCount;              // 7天内修改次数
    private final Instant firstModifyAt;        // 7天窗口起始时间
    
    private static final int WINDOW_DAYS = 7;
    private static final int MAX_MODIFY_COUNT = 2;
    
    private NicknameModifyWindow(int modifyCount, Instant firstModifyAt) {
        this.modifyCount = modifyCount;
        this.firstModifyAt = firstModifyAt;
    }
    
    // 初始状态（未修改过）
    public static NicknameModifyWindow initial() {
        return new NicknameModifyWindow(0, null);
    }
    
    public static NicknameModifyWindow of(int modifyCount, Instant firstModifyAt) {
        return new NicknameModifyWindow(modifyCount, firstModifyAt);
    }
    
    // 判断是否可以修改
    public boolean canModify(Instant now) {
        // 未修改过，可以修改
        if (modifyCount == 0 || firstModifyAt == null) {
            return true;
        }
        
        // 窗口已过期，可以修改
        if (isWindowExpired(now)) {
            return true;
        }
        
        // 窗口内，检查次数
        return modifyCount < MAX_MODIFY_COUNT;
    }
    
    // 记录一次修改
    public NicknameModifyWindow recordModify(Instant now) {
        if (!canModify(now)) {
            throw new IllegalStateException("昵称修改过于频繁，请稍后再试");
        }
        
        // 窗口已过期，重置计数
        if (isWindowExpired(now)) {
            return new NicknameModifyWindow(1, now);
        }
        
        // 首次修改
        if (modifyCount == 0) {
            return new NicknameModifyWindow(1, now);
        }
        
        // 窗口内，递增计数
        return new NicknameModifyWindow(modifyCount + 1, firstModifyAt);
    }
    
    // 判断窗口是否过期
    private boolean isWindowExpired(Instant now) {
        if (firstModifyAt == null) {
            return true;
        }
        Duration duration = Duration.between(firstModifyAt, now);
        return duration.toDays() >= WINDOW_DAYS;
    }
    
    // 计算距离下次可修改的时间
    public Duration getTimeUntilNextModify(Instant now) {
        if (canModify(now)) {
            return Duration.ZERO;
        }
        
        Instant windowEnd = firstModifyAt.plus(Duration.ofDays(WINDOW_DAYS));
        return Duration.between(now, windowEnd);
    }
    
    public int getModifyCount() {
        return modifyCount;
    }
    
    public Instant getFirstModifyAt() {
        return firstModifyAt;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        NicknameModifyWindow that = (NicknameModifyWindow) o;
        return modifyCount == that.modifyCount &&
               Objects.equals(firstModifyAt, that.firstModifyAt);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(modifyCount, firstModifyAt);
    }
}
```

---

#### 3.2.5 Avatar（头像）

**职责**：头像标识（仅允许系统预设头像）

```java
public class Avatar {
    private final String avatarId;
    
    private static final Set<String> PRESET_AVATARS = Set.of(
        "avatar-1", "avatar-2", "avatar-3", "avatar-4", "avatar-5",
        "avatar-6", "avatar-7", "avatar-8", "avatar-9", "avatar-10"
    );
    
    private Avatar(String avatarId) {
        this.avatarId = avatarId;
    }
    
    public static Avatar of(String avatarId) {
        if (avatarId == null || !PRESET_AVATARS.contains(avatarId)) {
            throw new IllegalArgumentException("无效的头像ID");
        }
        return new Avatar(avatarId);
    }
    
    public static Avatar defaultAvatar() {
        return new Avatar("avatar-1");
    }
    
    public String getAvatarId() {
        return avatarId;
    }
    
    // 获取头像URL（由基础设施层实现）
    public String getAvatarUrl(String baseUrl) {
        return baseUrl + "/avatars/" + avatarId + ".png";
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Avatar avatar = (Avatar) o;
        return Objects.equals(avatarId, avatar.avatarId);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(avatarId);
    }
    
    @Override
    public String toString() {
        return avatarId;
    }
}
```

---

#### 3.2.6 IpLocation（IP属地）

**职责**：IP属地（省 市）

```java
public class IpLocation {
    private final String province;  // 省
    private final String city;      // 市
    
    private IpLocation(String province, String city) {
        this.province = province;
        this.city = city;
    }
    
    public static IpLocation of(String province, String city) {
        if (province == null || province.trim().isEmpty()) {
            throw new IllegalArgumentException("省份不能为空");
        }
        return new IpLocation(province.trim(), city == null ? null : city.trim());
    }
    
    public String getProvince() {
        return province;
    }
    
    public String getCity() {
        return city;
    }
    
    // 格式化显示：广东 深圳
    public String format() {
        if (city == null || city.isEmpty()) {
            return province;
        }
        return province + " " + city;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        IpLocation that = (IpLocation) o;
        return Objects.equals(province, that.province) &&
               Objects.equals(city, that.city);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(province, city);
    }
    
    @Override
    public String toString() {
        return format();
    }
}
```

---

### 3.3 聚合根：DeviceSession（设备会话）

**职责**：管理多设备登录、token生命周期、设备踢出

**核心属性**：
```java
class DeviceSession {
    // 标识
    SessionId sessionId;        // 会话ID（值对象）
    UserId userId;              // 用户ID（值对象）
    DeviceId deviceId;          // 设备ID（值对象）
    
    // 设备信息
    DeviceInfo deviceInfo;      // 设备信息（值对象）
    
    // Token
    AccessToken accessToken;    // 访问token（值对象）
    RefreshToken refreshToken;  // 刷新token（值对象）
    
    // 登录信息
    IpAddress lastLoginIp;      // 最近登录IP（值对象）
    Instant lastLoginAt;        // 最近登录时间
    Instant lastActiveAt;       // 最近活跃时间
    
    // 状态
    SessionStatus status;       // 状态（枚举）
    Instant loggedOutAt;        // 退出时间
    
    // 审计
    Instant createdAt;
    Instant updatedAt;
}
```

**核心方法**：
```java
// 刷新token
void refreshToken(AccessToken newAccessToken, RefreshToken newRefreshToken);

// 更新活跃时间
void updateActiveTime();

// 退出登录
void logout();

// 判断token是否有效
boolean isTokenValid();

// 判断是否为当前设备
boolean isCurrentDevice(DeviceId currentDeviceId);
```

---

### 3.4 值对象详细设计（设备会话相关）

#### 3.4.1 DeviceInfo（设备信息）

**职责**：封装设备基本信息

```java
public class DeviceInfo {
    private final String deviceName;    // 设备名称（如 iPhone 15 Pro）
    private final Platform platform;    // 平台（iOS/Android）
    private final String osVersion;     // 系统版本
    private final String appVersion;    // APP版本号
    
    private DeviceInfo(String deviceName, Platform platform, String osVersion, String appVersion) {
        this.deviceName = deviceName;
        this.platform = platform;
        this.osVersion = osVersion;
        this.appVersion = appVersion;
    }
    
    public static DeviceInfo of(String deviceName, Platform platform, 
                                String osVersion, String appVersion) {
        if (deviceName == null || deviceName.trim().isEmpty()) {
            throw new IllegalArgumentException("设备名称不能为空");
        }
        if (platform == null) {
            throw new IllegalArgumentException("平台不能为空");
        }
        if (appVersion == null || appVersion.trim().isEmpty()) {
            throw new IllegalArgumentException("APP版本号不能为空");
        }
        return new DeviceInfo(deviceName.trim(), platform, osVersion, appVersion.trim());
    }
    
    public String getDeviceName() {
        return deviceName;
    }
    
    public Platform getPlatform() {
        return platform;
    }
    
    public String getOsVersion() {
        return osVersion;
    }
    
    public String getAppVersion() {
        return appVersion;
    }
    
    // 格式化显示：iPhone 15 Pro (iOS 17.2)
    public String format() {
        if (osVersion == null || osVersion.isEmpty()) {
            return String.format("%s (%s)", deviceName, platform);
        }
        return String.format("%s (%s %s)", deviceName, platform, osVersion);
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DeviceInfo that = (DeviceInfo) o;
        return Objects.equals(deviceName, that.deviceName) &&
               platform == that.platform &&
               Objects.equals(osVersion, that.osVersion) &&
               Objects.equals(appVersion, that.appVersion);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(deviceName, platform, osVersion, appVersion);
    }
}
```

---

### 3.5 领域服务

#### DeviceSessionDomainService（设备会话领域服务）

**职责**：管理多设备登录数量上限、设备踢出逻辑

```java
class DeviceSessionDomainService {
    private static final int MAX_DEVICE_COUNT = 10;
    
    // 检查设备数量是否超限
    void checkDeviceLimit(UserId userId, List<DeviceSession> activeSessions) {
        if (activeSessions.size() >= MAX_DEVICE_COUNT) {
            throw new DeviceLimitExceededException(
                String.format("设备数量已达上限（%d台）", MAX_DEVICE_COUNT)
            );
        }
    }
    
    // 踢出指定设备（不能踢出当前设备）
    void logoutDevice(DeviceSession targetSession, DeviceId currentDeviceId) {
        if (targetSession.isCurrentDevice(currentDeviceId)) {
            throw new IllegalArgumentException("不能踢出当前设备");
        }
        targetSession.logout();
    }
}
```

**为什么需要领域服务**：
- 设备数量上限校验涉及多个 `DeviceSession` 聚合，单个聚合无法完成
- 设备踢出逻辑需要比较"当前设备"与"目标设备"，需要额外上下文

---

### 3.6 仓储接口

```java
interface UserRepository {
    User findByUserId(UserId userId);
    User findByOpenId(WechatOpenId openId);
    void save(User user);
    List<User> findUsersToDeactivate(int uncheckDays);
}

interface DeviceSessionRepository {
    DeviceSession findBySessionId(SessionId sessionId);
    DeviceSession findByAccessToken(AccessToken accessToken);
    List<DeviceSession> findActiveSessionsByUserId(UserId userId);
    void save(DeviceSession session);
    int countActiveSessionsByUserId(UserId userId);
}
```

---

## 4. 任务上下文（Task Context）

### 4.1 聚合根：TaskAggregate（任务聚合）

**职责**：管理任务及其子任务，封装父子联动规则、重复任务策略

**核心属性**：
```java
class TaskAggregate {
    // 聚合根：Task
    Task task;                      // 父任务
    List<SubTask> subTasks;         // 子任务列表（最多20个）
}
```

**核心方法**：
```java
// 完成任务（需判断子任务是否全部完成）
void completeTask();

// 反完成任务
void uncompleteTask();

// 添加子任务
void addSubTask(SubTask subTask);

// 删除子任务
void removeSubTask(SubTaskId subTaskId);

// 完成子任务
void completeSubTask(SubTaskId subTaskId);

// 反完成子任务
void uncompleteSubTask(SubTaskId subTaskId);

// 判断是否可以完成（有子任务时，必须所有子任务已完成）
boolean canComplete();
```

---

### 4.2 实体：Task（任务）

**核心属性**：
```java
class Task {
    // 标识
    TaskId taskId;              // 任务ID（值对象）
    UserId userId;              // 用户ID（值对象）
    
    // 基本信息
    TaskTitle title;            // 任务标题（值对象）
    Priority priority;          // 优先级（值对象）
    TaskDate date;              // 归属日期（值对象）
    TaskStatus status;          // 状态（枚举）
    
    // 完成时间
    Instant completedAt;
    
    // 重复任务
    RepeatType repeatType;      // 重复类型（枚举）
    RepeatConfig repeatConfig;  // 重复配置（值对象）
    boolean isRepeatInstance;   // 是否为重复任务副本
    TaskId repeatParentId;      // 重复任务源ID
    
    // 审计
    Instant createdAt;
    Instant updatedAt;
    Instant deletedAt;
}
```

**核心方法**：
```java
// 完成任务
void complete();

// 反完成任务
void uncomplete();

// 更新任务信息
void update(TaskTitle title, Priority priority, TaskDate date);

// 逻辑删除
void delete();
```

---

### 4.3 实体：SubTask（子任务）

**核心属性**：
```java
class SubTask {
    // 标识
    SubTaskId subTaskId;        // 子任务ID（值对象）
    TaskId parentTaskId;        // 父任务ID（值对象）
    UserId userId;              // 用户ID（冗余字段）
    
    // 基本信息
    SubTaskTitle title;         // 子任务标题（值对象）
    TaskStatus status;          // 状态（枚举）
    
    // 完成时间
    Instant completedAt;
    
    // 重复任务
    RepeatType repeatType;
    RepeatConfig repeatConfig;
    boolean isRepeatInstance;
    SubTaskId repeatParentId;
    
    // 审计
    Instant createdAt;
    Instant updatedAt;
    Instant deletedAt;
}
```

---

### 4.4 值对象详细设计

#### 4.4.1 TaskTitle（任务标题）

**职责**：封装任务标题业务规则（1-100字符）

```java
public class TaskTitle {
    private final String value;
    
    private static final int MIN_LENGTH = 1;
    private static final int MAX_LENGTH = 100;
    
    private TaskTitle(String value) {
        this.value = value;
    }
    
    public static TaskTitle of(String value) {
        validate(value);
        return new TaskTitle(value.trim());
    }
    
    private static void validate(String value) {
        if (value == null || value.trim().isEmpty()) {
            throw new IllegalArgumentException("任务标题不能为空");
        }
        
        String trimmed = value.trim();
        if (trimmed.length() < MIN_LENGTH || trimmed.length() > MAX_LENGTH) {
            throw new IllegalArgumentException(
                String.format("任务标题长度必须在 %d-%d 字符之间", MIN_LENGTH, MAX_LENGTH)
            );
        }
    }
    
    public String getValue() {
        return value;
    }
    
    public boolean isEmpty() {
        return value.isEmpty();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TaskTitle taskTitle = (TaskTitle) o;
        return Objects.equals(value, taskTitle.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
    
    @Override
    public String toString() {
        return value;
    }
}
```

---

#### 4.4.2 Priority（优先级）

**职责**：四象限优先级，封装颜色、含义

```java
public enum Priority {
    P0("紧急且重要", "#FF0000"),      // 红色
    P1("重要不紧急", "#FF9800"),      // 橙色
    P2("紧急不重要", "#FFEB3B"),      // 黄色
    P3("不重要不紧急", "#4CAF50");    // 绿色
    
    private final String label;
    private final String color;
    
    Priority(String label, String color) {
        this.label = label;
        this.color = color;
    }
    
    public String getLabel() {
        return label;
    }
    
    public String getColor() {
        return color;
    }
    
    // 判断是否为高优先级（P0/P1）
    public boolean isHighPriority() {
        return this == P0 || this == P1;
    }
    
    // 判断是否紧急（P0/P2）
    public boolean isUrgent() {
        return this == P0 || this == P2;
    }
    
    // 判断是否重要（P0/P1）
    public boolean isImportant() {
        return this == P0 || this == P1;
    }
    
    @Override
    public String toString() {
        return name() + "（" + label + "）";
    }
}
```

---

#### 4.4.3 TaskDate（归属日期）

**职责**：任务归属日期，封装范围校验（今天-365 ~ 今天+365）

```java
public class TaskDate {
    private final LocalDate value;
    
    private static final int PAST_DAYS_LIMIT = 365;     // 历史1年
    private static final int FUTURE_DAYS_LIMIT = 365;   // 未来1年
    
    private TaskDate(LocalDate value) {
        this.value = value;
    }
    
    public static TaskDate of(LocalDate value) {
        validate(value);
        return new TaskDate(value);
    }
    
    public static TaskDate today() {
        return new TaskDate(LocalDate.now());
    }
    
    private static void validate(LocalDate value) {
        if (value == null) {
            throw new IllegalArgumentException("任务日期不能为空");
        }
        
        LocalDate today = LocalDate.now();
        LocalDate minDate = today.minusDays(PAST_DAYS_LIMIT);
        LocalDate maxDate = today.plusDays(FUTURE_DAYS_LIMIT);
        
        if (value.isBefore(minDate)) {
            throw new IllegalArgumentException(
                String.format("任务日期不能早于 %s（今天-365天）", minDate)
            );
        }
        
        if (value.isAfter(maxDate)) {
            throw new IllegalArgumentException(
                String.format("任务日期不能晚于 %s（今天+365天）", maxDate)
            );
        }
    }
    
    public LocalDate getValue() {
        return value;
    }
    
    // 判断是否为今天
    public boolean isToday() {
        return value.equals(LocalDate.now());
    }
    
    // 判断是否为过去日期
    public boolean isPast() {
        return value.isBefore(LocalDate.now());
    }
    
    // 判断是否为未来日期
    public boolean isFuture() {
        return value.isAfter(LocalDate.now());
    }
    
    // 计算逾期天数（N = today - taskDate）
    public int getOverdueDays() {
        if (!isPast()) {
            return 0;
        }
        return (int) ChronoUnit.DAYS.between(value, LocalDate.now());
    }
    
    // 格式化显示：今天/明天/后天/具体日期
    public String formatLabel() {
        LocalDate today = LocalDate.now();
        
        if (value.equals(today)) {
            return "今天";
        } else if (value.equals(today.plusDays(1))) {
            return "明天";
        } else if (value.equals(today.plusDays(2))) {
            return "后天";
        } else if (value.equals(today.minusDays(1))) {
            return "昨天";
        } else {
            return value.toString();
        }
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TaskDate taskDate = (TaskDate) o;
        return Objects.equals(value, taskDate.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
    
    @Override
    public String toString() {
        return value.toString();
    }
}
```

---

#### 4.4.4 RepeatConfig（重复配置）

**职责**：封装重复任务配置（每周哪几天、每月几号）

```java
public class RepeatConfig {
    private final RepeatType repeatType;
    private final List<Integer> weekdays;      // 每周：[1,3,5] 表示周一、周三、周五
    private final Integer dayOfMonth;          // 每月：1-31
    
    private RepeatConfig(RepeatType repeatType, List<Integer> weekdays, Integer dayOfMonth) {
        this.repeatType = repeatType;
        this.weekdays = weekdays;
        this.dayOfMonth = dayOfMonth;
    }
    
    // 不重复
    public static RepeatConfig none() {
        return new RepeatConfig(RepeatType.NONE, null, null);
    }
    
    // 每日重复
    public static RepeatConfig daily() {
        return new RepeatConfig(RepeatType.DAILY, null, null);
    }
    
    // 每周重复（指定星期几）
    public static RepeatConfig weekly(List<Integer> weekdays) {
        validateWeekdays(weekdays);
        return new RepeatConfig(RepeatType.WEEKLY, new ArrayList<>(weekdays), null);
    }
    
    // 每月重复（指定几号）
    public static RepeatConfig monthly(int dayOfMonth) {
        validateDayOfMonth(dayOfMonth);
        return new RepeatConfig(RepeatType.MONTHLY, null, dayOfMonth);
    }
    
    private static void validateWeekdays(List<Integer> weekdays) {
        if (weekdays == null || weekdays.isEmpty()) {
            throw new IllegalArgumentException("每周重复至少选择一天");
        }
        for (Integer day : weekdays) {
            if (day < 1 || day > 7) {
                throw new IllegalArgumentException("星期几必须在 1-7 之间");
            }
        }
    }
    
    private static void validateDayOfMonth(int dayOfMonth) {
        if (dayOfMonth < 1 || dayOfMonth > 31) {
            throw new IllegalArgumentException("日期必须在 1-31 之间");
        }
    }
    
    public RepeatType getRepeatType() {
        return repeatType;
    }
    
    public List<Integer> getWeekdays() {
        return weekdays == null ? null : Collections.unmodifiableList(weekdays);
    }
    
    public Integer getDayOfMonth() {
        return dayOfMonth;
    }
    
    // 判断指定日期是否符合重复规则
    public boolean matchesDate(LocalDate date) {
        switch (repeatType) {
            case NONE:
                return false;
            case DAILY:
                return true;
            case WEEKLY:
                int dayOfWeek = date.getDayOfWeek().getValue(); // 1-7
                return weekdays.contains(dayOfWeek);
            case MONTHLY:
                return date.getDayOfMonth() == dayOfMonth;
            default:
                return false;
        }
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        RepeatConfig that = (RepeatConfig) o;
        return repeatType == that.repeatType &&
               Objects.equals(weekdays, that.weekdays) &&
               Objects.equals(dayOfMonth, that.dayOfMonth);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(repeatType, weekdays, dayOfMonth);
    }
}
```

---

### 4.5 领域服务

#### TaskCompletionDomainService（任务完成领域服务）

**职责**：封装父子任务联动规则

```java
class TaskCompletionDomainService {
    
    // 完成父任务（需校验所有子任务是否已完成）
    void completeTask(TaskAggregate taskAggregate) {
        if (!taskAggregate.canComplete()) {
            throw new IllegalStateException("存在未完成的子任务，无法完成父任务");
        }
        taskAggregate.task.complete();
    }
    
    // 反完成父任务
    void uncompleteTask(TaskAggregate taskAggregate) {
        taskAggregate.task.uncomplete();
    }
    
    // 完成子任务（触发父任务状态重算）
    void completeSubTask(TaskAggregate taskAggregate, SubTaskId subTaskId) {
        SubTask subTask = findSubTask(taskAggregate, subTaskId);
        subTask.complete();
        
        // 重算父任务状态
        recalculateTaskStatus(taskAggregate);
    }
    
    // 反完成子任务（触发父任务状态重算）
    void uncompleteSubTask(TaskAggregate taskAggregate, SubTaskId subTaskId) {
        SubTask subTask = findSubTask(taskAggregate, subTaskId);
        subTask.uncomplete();
        
        // 重算父任务状态
        recalculateTaskStatus(taskAggregate);
    }
    
    // 新增子任务（若父任务已完成，自动变为未完成）
    void addSubTask(TaskAggregate taskAggregate, SubTask newSubTask) {
        if (taskAggregate.getSubTasks().size() >= 20) {
            throw new IllegalStateException("子任务数量已达上限（20条）");
        }
        
        taskAggregate.addSubTask(newSubTask);
        
        // 如果父任务已完成，自动变为未完成
        if (taskAggregate.task.getStatus() == TaskStatus.COMPLETED) {
            taskAggregate.task.uncomplete();
        }
    }
    
    // 删除子任务（触发父任务状态重算）
    void deleteSubTask(TaskAggregate taskAggregate, SubTaskId subTaskId) {
        taskAggregate.removeSubTask(subTaskId);
        
        // 重算父任务状态
        recalculateTaskStatus(taskAggregate);
    }
    
    // 重算父任务完成状态
    private void recalculateTaskStatus(TaskAggregate taskAggregate) {
        List<SubTask> subTasks = taskAggregate.getSubTasks();
        
        // 无子任务，不变更状态
        if (subTasks.isEmpty()) {
            return;
        }
        
        // 所有子任务已完成 → 父任务完成
        boolean allCompleted = subTasks.stream()
            .allMatch(sub -> sub.getStatus() == TaskStatus.COMPLETED);
        
        if (allCompleted) {
            taskAggregate.task.complete();
        } else {
            taskAggregate.task.uncomplete();
        }
    }
    
    private SubTask findSubTask(TaskAggregate taskAggregate, SubTaskId subTaskId) {
        return taskAggregate.getSubTasks().stream()
            .filter(sub -> sub.getSubTaskId().equals(subTaskId))
            .findFirst()
            .orElseThrow(() -> new IllegalArgumentException("子任务不存在"));
    }
}
```

**为什么需要领域服务**：
- 父子任务联动涉及 `Task` 和 `SubTask` 两个实体，单个实体无法完成
- 状态联动规则复杂，需要独立封装（符合单一职责原则）

---

### 4.6 仓储接口

```java
interface TaskRepository {
    TaskAggregate findByTaskId(TaskId taskId);
    List<TaskAggregate> findByUserAndDate(UserId userId, TaskDate date);
    List<TaskAggregate> findByUserAndDateRange(UserId userId, LocalDate startDate, LocalDate endDate);
    void save(TaskAggregate taskAggregate);
    void delete(TaskId taskId);
    int countByUserAndDate(UserId userId, TaskDate date);
    void deleteRepeatInstances(TaskId repeatParentId);
}
```

---

## 5. 打卡上下文（CheckIn Context）

### 5.1 聚合根：CheckIn（打卡记录）

**职责**：记录每日打卡，维护连续打卡天数

**核心属性**：
```java
class CheckIn {
    // 标识
    CheckInId checkInId;        // 打卡ID（值对象）
    UserId userId;              // 用户ID（值对象）
    
    // 打卡信息
    LocalDate date;             // 打卡日期（本地时区）
    Instant checkedAt;          // 打卡时间（UTC）
    ConsecutiveDays consecutiveDays; // 打卡时的连续天数（快照）
    
    // 审计
    Instant createdAt;
    Instant updatedAt;
}
```

**核心方法**：
```java
// 创建打卡记录
static CheckIn create(UserId userId, LocalDate date, ConsecutiveDays consecutiveDays);
```

---

### 5.2 值对象详细设计

#### 5.2.1 CheckInId（打卡ID）

```java
public class CheckInId {
    private final String value;
    
    private CheckInId(String value) {
        this.value = value;
    }
    
    public static CheckInId newId() {
        return new CheckInId(UUID.randomUUID().toString());
    }
    
    public static CheckInId of(String value) {
        if (value == null || value.trim().isEmpty()) {
            throw new IllegalArgumentException("打卡ID不能为空");
        }
        return new CheckInId(value);
    }
    
    public String getValue() {
        return value;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        CheckInId that = (CheckInId) o;
        return Objects.equals(value, that.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
    
    @Override
    public String toString() {
        return value;
    }
}
```

---

### 5.3 领域服务

#### CheckInDomainService（打卡领域服务）

**职责**：计算连续打卡天数、触发用户打卡统计更新

```java
class CheckInDomainService {
    
    // 执行打卡（幂等，当日重复打卡无副作用）
    CheckIn performCheckIn(UserId userId, LocalDate date, User user, CheckInRepository repository) {
        // 幂等校验：当日已打卡
        CheckIn existing = repository.findByUserAndDate(userId, date);
        if (existing != null) {
            return existing;
        }
        
        // 校验日期（不能是未来日期）
        validateCheckInDate(date);
        
        // 计算连续打卡天数
        ConsecutiveDays consecutiveDays = calculateConsecutiveDays(userId, date, repository);
        
        // 创建打卡记录
        CheckIn checkIn = CheckIn.create(userId, date, consecutiveDays);
        repository.save(checkIn);
        
        // 更新用户打卡统计
        user.updateCheckInStats(consecutiveDays, date);
        
        return checkIn;
    }
    
    // 计算连续打卡天数
    ConsecutiveDays calculateConsecutiveDays(UserId userId, LocalDate checkInDate, 
                                             CheckInRepository repository) {
        // 查询最近打卡记录
        List<CheckIn> recentCheckIns = repository.findRecentCheckIns(userId, 30);
        
        if (recentCheckIns.isEmpty()) {
            // 首次打卡
            return ConsecutiveDays.of(1);
        }
        
        // 按日期降序排列
        recentCheckIns.sort((a, b) -> b.getDate().compareTo(a.getDate()));
        
        // 查找连续打卡序列
        int consecutive = 1; // 包含今天
        LocalDate expectedDate = checkInDate.minusDays(1);
        
        for (CheckIn checkIn : recentCheckIns) {
            if (checkIn.getDate().equals(expectedDate)) {
                consecutive++;
                expectedDate = expectedDate.minusDays(1);
            } else {
                break;
            }
        }
        
        return ConsecutiveDays.of(consecutive);
    }
    
    // 校验打卡日期
    void validateCheckInDate(LocalDate checkInDate) {
        if (checkInDate.isAfter(LocalDate.now())) {
            throw new IllegalArgumentException("不能打卡未来日期");
        }
    }
}
```

---

### 5.4 仓储接口

```java
interface CheckInRepository {
    CheckIn findByUserAndDate(UserId userId, LocalDate date);
    List<CheckIn> findRecentCheckIns(UserId userId, int days);
    void save(CheckIn checkIn);
}
```

---

## 6. 专注上下文（Focus Context）

### 6.1 聚合根：FocusSession（专注会话）

**职责**：管理专注倒计时会话、计入规则

**核心属性**：
```java
class FocusSession {
    // 标识
    SessionId sessionId;        // 会话ID（值对象）
    UserId userId;              // 用户ID（值对象）
    
    // 会话信息
    FocusDuration duration;     // 预设时长（值对象）
    FocusType type;             // 专注类型（枚举）
    SessionStatus status;       // 状态（枚举）
    
    // 时间记录
    Instant startAt;            // 开始时间
    Instant endAt;              // 结束时间
    int elapsedSeconds;         // 已完成秒数
    
    // 计入规则
    EndType endType;            // 结束类型（枚举）
    boolean counted;            // 是否计入总时长
    int countedSeconds;         // 计入的秒数
    
    // 审计
    Instant createdAt;
    Instant updatedAt;
}
```

**核心方法**：
```java
// 开始专注
static FocusSession start(UserId userId, FocusDuration duration, FocusType type);

// 中断专注（后台/来电/锁屏）
void interrupt();

// 恢复专注（从中断状态恢复）
void resume();

// 结束专注（自然结束或手动结束）
void end(int elapsedSeconds, EndType endType);
```

**业务规则**：
- 自然结束：100% 计入
- 手动结束：`elapsedSeconds / durationSeconds >= 50%` 则计入，否则不计入

---

### 6.2 值对象详细设计

#### 6.2.1 FocusDuration（专注时长）

**职责**：封装专注时长（15/25/30/45/60分钟）

```java
public class FocusDuration {
    private final int minutes;
    
    private static final Set<Integer> ALLOWED_DURATIONS = Set.of(15, 25, 30, 45, 60);
    
    private FocusDuration(int minutes) {
        this.minutes = minutes;
    }
    
    public static FocusDuration of(int minutes) {
        if (!ALLOWED_DURATIONS.contains(minutes)) {
            throw new IllegalArgumentException(
                "专注时长必须为 15/25/30/45/60 分钟之一"
            );
        }
        return new FocusDuration(minutes);
    }
    
    public int getMinutes() {
        return minutes;
    }
    
    public int getSeconds() {
        return minutes * 60;
    }
    
    // 判断指定秒数是否达到50%阈值
    public boolean isHalfway(int elapsedSeconds) {
        return elapsedSeconds >= getSeconds() / 2;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FocusDuration that = (FocusDuration) o;
        return minutes == that.minutes;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(minutes);
    }
    
    @Override
    public String toString() {
        return minutes + " 分钟";
    }
}
```

---

#### 6.2.2 SessionId（会话ID）

```java
public class SessionId {
    private final String value;
    
    private SessionId(String value) {
        this.value = value;
    }
    
    public static SessionId newId() {
        return new SessionId(UUID.randomUUID().toString());
    }
    
    public static SessionId of(String value) {
        if (value == null || value.trim().isEmpty()) {
            throw new IllegalArgumentException("会话ID不能为空");
        }
        return new SessionId(value);
    }
    
    public String getValue() {
        return value;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SessionId sessionId = (SessionId) o;
        return Objects.equals(value, sessionId.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
    
    @Override
    public String toString() {
        return value;
    }
}
```

---

### 6.3 实体：FocusStats（专注统计）

**职责**：汇总表，避免每次聚合计算

**核心属性**：
```java
class FocusStats {
    UserId userId;
    long totalSeconds;      // 累计总专注时长（秒）
    int totalHours;         // 累计总专注时长（小时，向下取整）
    int sessionCount;       // 累计会话次数
    
    Instant createdAt;
    Instant updatedAt;
}
```

**核心方法**：
```java
// 增加专注时长
void addFocusTime(int countedSeconds) {
    this.totalSeconds += countedSeconds;
    this.totalHours = (int) (this.totalSeconds / 3600);
    this.sessionCount++;
}
```

---

### 6.4 领域服务

#### FocusStatsDomainService（专注统计领域服务）

**职责**：更新用户累计专注时长

```java
class FocusStatsDomainService {
    
    // 更新用户总专注时长（会话结束时调用）
    void updateTotalFocusTime(UserId userId, int countedSeconds, FocusStatsRepository repository) {
        FocusStats stats = repository.findByUserId(userId);
        
        if (stats == null) {
            // 首次专注，创建统计记录
            stats = FocusStats.create(userId);
        }
        
        stats.addFocusTime(countedSeconds);
        repository.save(stats);
    }
    
    // 查询用户总专注时长
    FocusStats getTotalFocusTime(UserId userId, FocusStatsRepository repository) {
        return repository.findByUserId(userId);
    }
}
```

---

### 6.5 仓储接口

```java
interface FocusSessionRepository {
    FocusSession findBySessionId(SessionId sessionId);
    FocusSession findRunningSession(UserId userId);
    void save(FocusSession session);
}

interface FocusStatsRepository {
    FocusStats findByUserId(UserId userId);
    void save(FocusStats stats);
}
```

---

## 7. 会员上下文（Membership Context）

### 7.1 聚合根：Entitlement（权益）

**职责**：管理用户会员权益、免费期、到期判断

**核心属性**：
```java
class Entitlement {
    // 标识
    UserId userId;
    
    // 权益状态
    EntitlementStatus status; // 枚举
    
    // 免费期
    Instant trialStartAt;     // 免费期起算时间
    Instant trialExpireAt;    // 免费期到期时间
    
    // 会员有效期
    Instant expireAt;         // 会员到期时间
    
    // 审计
    Instant createdAt;
    Instant updatedAt;
}
```

**核心方法**：
```java
// 激活免费期（首次登录）
void activateFreeTrial();

// 购买会员（延长到期时间）
void purchaseMembership(MembershipPlan plan);

// 判断当前状态
EntitlementStatus calculateStatus(Instant now);

// 判断是否有效（免费期有效 或 会员有效）
boolean isValid(Instant now);

// 退款（立即到期）
void refund();
```

---

### 7.2 聚合根：Order（订单）

**职责**：管理充值订单、支付状态、幂等

**核心属性**：
```java
class Order {
    // 标识
    OrderId orderId;          // 订单ID（值对象）
    UserId userId;            // 用户ID（值对象）
    
    // 订单信息
    MembershipPlan plan;      // 套餐类型（值对象）
    Money amount;             // 金额（值对象）
    
    // 支付信息
    PaymentMethod paymentMethod; // 支付方式（枚举）
    String paymentChannelOrderId; // 支付渠道订单号
    
    // 订单状态
    OrderStatus status;       // 状态（枚举）
    Instant paidAt;           // 支付时间
    Instant refundedAt;       // 退款时间
    Instant expireAt;         // 订单过期时间（15分钟）
    
    // 审计
    Instant createdAt;
    Instant updatedAt;
}
```

**核心方法**：
```java
// 创建订单
static Order create(UserId userId, MembershipPlan plan, PaymentMethod paymentMethod);

// 支付成功（幂等）
void markAsPaid(String paymentChannelOrderId, Instant paidAt);

// 订单过期
void markAsExpired();

// 退款
void refund();

// 判断订单是否已过期
boolean isExpired(Instant now);
```

---

### 7.3 值对象详细设计

#### 7.3.1 MembershipPlan（套餐类型）

**职责**：封装套餐类型、时长、价格

```java
public enum MembershipPlan {
    MONTH(1, 1200, "月"),
    QUARTER(3, 3000, "季"),
    YEAR(12, 10800, "年");
    
    private final int months;       // 时长（月）
    private final int priceInCents; // 价格（分）
    private final String label;
    
    MembershipPlan(int months, int priceInCents, String label) {
        this.months = months;
        this.priceInCents = priceInCents;
        this.label = label;
    }
    
    public int getMonths() {
        return months;
    }
    
    public int getPriceInCents() {
        return priceInCents;
    }
    
    public String getLabel() {
        return label;
    }
    
    // 计算到期时间（从指定时间起算）
    public Instant calculateExpireAt(Instant from) {
        return from.plus(Duration.ofDays(months * 30));
    }
    
    @Override
    public String toString() {
        return label + "（" + (priceInCents / 100.0) + " 元）";
    }
}
```

---

#### 7.3.2 Money（金额）

**职责**：封装金额（币种+金额），封装金额运算

```java
public class Money {
    private final int amountInCents;    // 金额（分）
    private final String currency;      // 币种
    
    private Money(int amountInCents, String currency) {
        this.amountInCents = amountInCents;
        this.currency = currency;
    }
    
    public static Money ofCents(int cents, String currency) {
        if (cents < 0) {
            throw new IllegalArgumentException("金额不能为负数");
        }
        if (currency == null || currency.trim().isEmpty()) {
            throw new IllegalArgumentException("币种不能为空");
        }
        return new Money(cents, currency.toUpperCase());
    }
    
    public static Money ofYuan(double yuan, String currency) {
        return ofCents((int) (yuan * 100), currency);
    }
    
    public static Money cny(int cents) {
        return ofCents(cents, "CNY");
    }
    
    public int getAmountInCents() {
        return amountInCents;
    }
    
    public double getAmountInYuan() {
        return amountInCents / 100.0;
    }
    
    public String getCurrency() {
        return currency;
    }
    
    // 金额运算
    public Money add(Money other) {
        if (!currency.equals(other.currency)) {
            throw new IllegalArgumentException("币种不一致，无法相加");
        }
        return new Money(amountInCents + other.amountInCents, currency);
    }
    
    public Money subtract(Money other) {
        if (!currency.equals(other.currency)) {
            throw new IllegalArgumentException("币种不一致，无法相减");
        }
        if (amountInCents < other.amountInCents) {
            throw new IllegalArgumentException("金额不足");
        }
        return new Money(amountInCents - other.amountInCents, currency);
    }
    
    // 判断金额是否为零
    public boolean isZero() {
        return amountInCents == 0;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Money money = (Money) o;
        return amountInCents == money.amountInCents &&
               Objects.equals(currency, money.currency);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(amountInCents, currency);
    }
    
    @Override
    public String toString() {
        return String.format("%.2f %s", getAmountInYuan(), currency);
    }
}
```

---

#### 7.3.3 OrderId（订单ID）

```java
public class OrderId {
    private final String value;
    
    private OrderId(String value) {
        this.value = value;
    }
    
    public static OrderId newId() {
        return new OrderId(UUID.randomUUID().toString());
    }
    
    public static OrderId of(String value) {
        if (value == null || value.trim().isEmpty()) {
            throw new IllegalArgumentException("订单ID不能为空");
        }
        return new OrderId(value);
    }
    
    public String getValue() {
        return value;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        OrderId orderId = (OrderId) o;
        return Objects.equals(value, orderId.value);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
    
    @Override
    public String toString() {
        return value;
    }
}
```

---

### 7.4 领域服务

#### PaymentDomainService（支付领域服务）

**职责**：处理支付回调、更新权益、幂等控制

```java
class PaymentDomainService {
    
    // 处理支付回调（幂等）
    void handlePaymentCallback(String paymentChannelOrderId, Order order, Entitlement entitlement) {
        // 幂等校验：订单已支付
        if (order.getStatus() == OrderStatus.PAID) {
            return;
        }
        
        // 更新订单状态
        order.markAsPaid(paymentChannelOrderId, Instant.now());
        
        // 延长会员有效期
        extendMembership(entitlement, order.getPlan());
    }
    
    // 延长会员有效期
    void extendMembership(Entitlement entitlement, MembershipPlan plan) {
        entitlement.purchaseMembership(plan);
    }
}
```

**为什么需要领域服务**：
- 支付回调需要同时更新 `Order` 和 `Entitlement` 两个聚合（跨聚合协作）
- 幂等控制需要查询历史订单，单个聚合无法完成

---

### 7.5 仓储接口

```java
interface EntitlementRepository {
    Entitlement findByUserId(UserId userId);
    void save(Entitlement entitlement);
}

interface OrderRepository {
    Order findByOrderId(OrderId orderId);
    Order findByPaymentChannelOrderId(String paymentChannelOrderId);
    void save(Order order);
    List<Order> findExpiredOrders(Instant now);
}
```

---

## 8. 共享内核（Shared Kernel）

### 8.1 公共值对象

| 值对象 | 职责 | 使用场景 |
|--------|------|----------|
| **UserId** | 用户唯一标识（UUID） | 所有上下文 |
| **Instant** | 时间戳（UTC） | 所有上下文 |
| **LocalDate** | 本地日期 | 任务、打卡 |

### 8.2 公共枚举

#### AccountStatus（账号状态）

```java
public enum AccountStatus {
    ACTIVE("正常"),
    DEACTIVATED("已注销");
    
    private final String label;
    
    AccountStatus(String label) {
        this.label = label;
    }
    
    public String getLabel() {
        return label;
    }
}
```

---

#### TaskStatus（任务状态）

```java
public enum TaskStatus {
    INCOMPLETE("未完成"),
    COMPLETED("已完成");
    
    private final String label;
    
    TaskStatus(String label) {
        this.label = label;
    }
    
    public String getLabel() {
        return label;
    }
}
```

---

#### RepeatType（重复类型）

```java
public enum RepeatType {
    NONE("不重复"),
    DAILY("每日"),
    WEEKLY("每周"),
    MONTHLY("每月");
    
    private final String label;
    
    RepeatType(String label) {
        this.label = label;
    }
    
    public String getLabel() {
        return label;
    }
}
```

---

#### FocusType（专注类型）

```java
public enum FocusType {
    WORK("工作"),
    STUDY("学习"),
    READING("阅读"),
    CODING("编程"),
    EXERCISE("运动"),
    MEDITATION("冥想"),
    OTHER("其它");
    
    private final String label;
    
    FocusType(String label) {
        this.label = label;
    }
    
    public String getLabel() {
        return label;
    }
}
```

---

#### SessionStatus（会话状态）

```java
public enum SessionStatus {
    RUNNING("进行中"),
    INTERRUPTED("已中断"),
    COMPLETED("已完成");
    
    private final String label;
    
    SessionStatus(String label) {
        this.label = label;
    }
    
    public String getLabel() {
        return label;
    }
}
```

---

#### EndType（结束类型）

```java
public enum EndType {
    NATURAL("自然结束"),
    MANUAL("手动结束");
    
    private final String label;
    
    EndType(String label) {
        this.label = label;
    }
    
    public String getLabel() {
        return label;
    }
}
```

---

#### EntitlementStatus（权益状态）

```java
public enum EntitlementStatus {
    NOT_ENTITLED("未激活"),
    FREE_TRIAL("免费期"),
    MEMBER_ACTIVE("会员有效"),
    EXPIRED("已到期");
    
    private final String label;
    
    EntitlementStatus(String label) {
        this.label = label;
    }
    
    public String getLabel() {
        return label;
    }
}
```

---

#### OrderStatus（订单状态）

```java
public enum OrderStatus {
    PENDING("待支付"),
    PAID("已支付"),
    EXPIRED("已过期"),
    REFUNDED("已退款");
    
    private final String label;
    
    OrderStatus(String label) {
        this.label = label;
    }
    
    public String getLabel() {
        return label;
    }
}
```

---

#### PaymentMethod（支付方式）

```java
public enum PaymentMethod {
    WECHAT_PAY("微信支付"),
    ALIPAY("支付宝");
    
    private final String label;
    
    PaymentMethod(String label) {
        this.label = label;
    }
    
    public String getLabel() {
        return label;
    }
}
```

---

#### Platform（平台）

```java
public enum Platform {
    IOS("iOS"),
    ANDROID("Android");
    
    private final String label;
    
    Platform(String label) {
        this.label = label;
    }
    
    public String getLabel() {
        return label;
    }
}
```

---

**文档结束**
